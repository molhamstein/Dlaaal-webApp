import { Observable } from 'rxjs';
import { Observable as Observable$1 } from 'rxjs/Observable';
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

var ResizeOptions = (function () {
    function ResizeOptions() {
        this.Resize_Max_Height = 800;
        this.Resize_Max_Width = 1000;
        this.Resize_Quality = 70;
        this.Resize_Type = 'image/jpg';
    }
    return ResizeOptions;
}());

var SourceImage = (function () {
    function SourceImage() {
    }
    return SourceImage;
}());

var ImageUtilityService = (function () {
    function ImageUtilityService() {
    }
    /**
     * @param {?} url
     * @param {?} callback
     * @return {?}
     */
    ImageUtilityService.createImage = function (url, callback) {
        var /** @type {?} */ image = new Image();
        image.onload = function () {
            callback(image);
        };
        image.src = url;
    };
    /**
     * @param {?} file
     * @return {?}
     */
    ImageUtilityService.fileToDataURL = function (file) {
        return new Promise(function (resolve) {
            var /** @type {?} */ reader = new FileReader();
            reader.onload = function (e) {
                resolve(e.target.result);
            };
            reader.readAsDataURL(file);
        });
    };
    /**
     * @param {?} fileList
     * @return {?}
     */
    ImageUtilityService.filesToSourceImages = function (fileList) {
        return Observable.create(function (observer) {
            var /** @type {?} */ total = fileList.length;
            Array.from(fileList).forEach(function (fileItem) {
                var /** @type {?} */ imageResult = new SourceImage();
                console.log(fileItem.name);
                imageResult.fileName = fileItem.name;
                imageResult.type = fileItem.type;
                imageResult.imageObjectUrl = URL.createObjectURL(fileItem);
                ImageUtilityService.fileToDataURL(fileItem).then(function (result) {
                    imageResult.imageDataUrl = result;
                    observer.next(imageResult);
                    if (--total === 0)
                        observer.complete();
                });
            });
        });
    };
    /**
     * @param {?} fileList
     * @return {?}
     */
    ImageUtilityService.filesArrayToSourceImages = function (fileList) {
        return Observable.create(function (observer) {
            var /** @type {?} */ total = fileList.length;
            fileList.forEach(function (fileItem) {
                var /** @type {?} */ imageResult = new SourceImage();
                console.log(fileItem.name);
                // imageResult.fileName = fileItem.name;
                imageResult.imageObjectUrl = URL.createObjectURL(fileItem);
                ImageUtilityService.fileToDataURL(fileItem).then(function (result) {
                    imageResult.imageDataUrl = result;
                    observer.next(imageResult);
                    if (--total === 0)
                        observer.complete();
                });
            });
        });
    };
    return ImageUtilityService;
}());

var ImageCompressService = (function () {
    function ImageCompressService() {
    }
    /**
     * Receives an Image Object (can be JPG OR PNG) and returns a new Image Object compressed
    \@param {Image} sourceImgObj The source Image Object
    \@param {Integer} quality The output quality of Image Object
    \@return {Image} result_image_obj The compressed Image Object
     * @param {?} sourceImgObj
     * @param {?} options
     * @return {?}
     */
    ImageCompressService.jicCompress = function (sourceImgObj, options) {
        var /** @type {?} */ outputFormat = options.Resize_Type;
        var /** @type {?} */ quality = options.Resize_Quality || 50;
        var /** @type {?} */ mimeType = 'image/jpeg';
        if (outputFormat !== undefined && outputFormat === 'png') {
            mimeType = 'image/png';
        }
        var /** @type {?} */ maxHeight = options.Resize_Max_Height || 300;
        var /** @type {?} */ maxWidth = options.Resize_Max_Width || 250;
        console.log('MAX Width n Height');
        console.log(options.Resize_Max_Height);
        console.log(options.Resize_Max_Width);
        console.log('Quality');
        console.log(quality);
        var /** @type {?} */ height = sourceImgObj.height;
        var /** @type {?} */ width = sourceImgObj.width;
        // calculate the width and height, constraining the proportions
        if (width > height) {
            if (width > maxWidth) {
                height = Math.round(height *= maxWidth / width);
                width = maxWidth;
            }
        }
        else {
            if (height > maxHeight) {
                width = Math.round(width *= maxHeight / height);
                height = maxHeight;
            }
        }
        console.log('CVS Width n Height');
        console.log(width);
        console.log(height);
        console.log('Quality');
        console.log(quality);
        var /** @type {?} */ cvs = document.createElement('canvas');
        cvs.width = width;
        cvs.height = height;
        var /** @type {?} */ ctx = cvs.getContext('2d').drawImage(sourceImgObj, 0, 0, width, height);
        var /** @type {?} */ newImageData = cvs.toDataURL(mimeType, quality / 100);
        var /** @type {?} */ resultImageObj = new Image();
        resultImageObj.src = newImageData;
        return resultImageObj.src;
    };
    /**
     * @param {?} sourceImage
     * @param {?} options
     * @param {?} callback
     * @return {?}
     */
    ImageCompressService.compressImage = function (sourceImage, options, callback) {
        var /** @type {?} */ that = this;
        ImageUtilityService.createImage(sourceImage.imageDataUrl, function (image) {
            var /** @type {?} */ dataURLcompressed = that.jicCompress(image, options);
            sourceImage.compressedImage = {
                fileName: sourceImage.fileName,
                imageObjectUrl: "",
                imageDataUrl: dataURLcompressed,
                type: dataURLcompressed.match(/:(.+\/.+);/)[1],
                compressedImage: null
            };
            callback(sourceImage);
        });
    };
    /**
     * @param {?} fileList
     * @param {?} option
     * @return {?}
     */
    ImageCompressService.filesToCompressedImageSourceEx = function (fileList, option) {
        return new Promise(function (resolve, reject) {
            var /** @type {?} */ count = fileList.length;
            var /** @type {?} */ observer = ImageUtilityService.filesToSourceImages(fileList);
            var /** @type {?} */ images = [];
            observer.subscribe(function (image) {
                images.push(image);
                if (option == null) {
                    option = new ResizeOptions();
                }
                ImageCompressService.compressImage(image, option, function (imageRef) {
                    if (--count == 0) {
                        resolve(Observable$1.from(images));
                    }
                });
            }, function (error) {
                reject("Error while compressing images");
            });
        });
    };
    /**
     * @param {?} fileList
     * @return {?}
     */
    ImageCompressService.filesToCompressedImageSource = function (fileList) {
        return new Promise(function (resolve, reject) {
            var /** @type {?} */ count = fileList.length;
            var /** @type {?} */ observer = ImageUtilityService.filesToSourceImages(fileList);
            var /** @type {?} */ images = [];
            observer.subscribe(function (image) {
                images.push(image);
                ImageCompressService.compressImage(image, new ResizeOptions(), function (imageRef) {
                    if (--count == 0) {
                        resolve(Observable$1.from(images));
                    }
                });
            }, function (error) {
                reject("Error while compressing images");
            });
        });
    };
    /**
     * @param {?} fileList
     * @param {?} option
     * @return {?}
     */
    ImageCompressService.filesArrayToCompressedImageSourceEx = function (fileList, option) {
        return new Promise(function (resolve, reject) {
            var /** @type {?} */ count = fileList.length;
            var /** @type {?} */ observer = ImageUtilityService.filesArrayToSourceImages(fileList);
            var /** @type {?} */ images = [];
            observer.subscribe(function (image) {
                images.push(image);
                if (option == null) {
                    option = new ResizeOptions();
                }
                ImageCompressService.compressImage(image, option, function (imageRef) {
                    if (--count == 0) {
                        resolve(Observable$1.from(images));
                    }
                });
            }, function (error) {
                reject("Error while compressing images");
            });
        });
    };
    /**
     * @param {?} fileList
     * @return {?}
     */
    ImageCompressService.filesArrayToCompressedImageSource = function (fileList) {
        return new Promise(function (resolve, reject) {
            var /** @type {?} */ count = fileList.length;
            var /** @type {?} */ observer = ImageUtilityService.filesArrayToSourceImages(fileList);
            var /** @type {?} */ images = [];
            observer.subscribe(function (image) {
                images.push(image);
                ImageCompressService.compressImage(image, new ResizeOptions(), function (imageRef) {
                    if (--count == 0) {
                        resolve(Observable$1.from(images));
                    }
                });
            }, function (error) {
                reject("Error while compressing images");
            });
        });
    };
    /**
     * @param {?} images
     * @return {?}
     */
    ImageCompressService.IImageListToCompressedImageSource = function (images) {
        return new Promise(function (resolve, reject) {
            var /** @type {?} */ count = images.length;
            images.forEach(function (image) {
                ImageCompressService.compressImage(image, new ResizeOptions(), function (imageRef) {
                    console.log(image);
                    if (--count == 0) {
                        resolve(images);
                    }
                });
            });
        });
    };
    /**
     * @param {?} images
     * @param {?} resizeOption
     * @return {?}
     */
    ImageCompressService.IImageListToCompressedImageSourceEx = function (images, resizeOption) {
        return new Promise(function (resolve, reject) {
            var /** @type {?} */ count = images.length;
            images.forEach(function (image) {
                if (resizeOption == null) {
                    resizeOption = new ResizeOptions();
                }
                ImageCompressService.compressImage(image, resizeOption, function (imageRef) {
                    console.log(image);
                    if (--count == 0) {
                        resolve(images);
                    }
                });
            });
        });
    };
    return ImageCompressService;
}());

var ImageCompressModule = (function () {
    function ImageCompressModule() {
    }
    /**
     * @return {?}
     */
    ImageCompressModule.forRoot = function () {
        return {
            ngModule: ImageCompressModule,
            providers: [ImageCompressService, ImageUtilityService]
        };
    };
    return ImageCompressModule;
}());
ImageCompressModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ]
            },] },
];
/**
 * @nocollapse
 */
ImageCompressModule.ctorParameters = function () { return []; };

export { ResizeOptions, SourceImage, ImageCompressService, ImageUtilityService, ImageCompressModule };
